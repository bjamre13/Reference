User Stories
Project user story

As a customer, I want to be able to create a new support ticket so that I can request assistance for my problems.

As a support agent, I want to view all assigned tickets in a dashboard so that I can efficiently manage my workload.

As a support agent, I want to update the status of a ticket so that everyone involved knows the current progress

As a customer, I want to receive notifications when there are updates to my tickets so that I'm always informed of progress

As a support agent, I want to add internal notes and customer-visible comments to tickets so that i can document progress and communicate with customers.

As a support agent, I want to update ticket status and add comments so that I can communicate progress to customers.

As an administrator, I want to view performance metrics and reports so that I can evaluate support team effectiveness and identify improvement areas.

As a customer, I want to attach files to tickets so that I can provide screenshots or documents that help explain my issue.

As an administrator, I want to manage user roles and permissions so that I can control access to different system functions.

As a support agent, I want to search for tickets using keywords so that I can quickly find relevant tickets when helping customers

As a user, I want to reset my password if I forget it so that I can regain access to my account.

As a customer, I want to rate my support experience after ticket resolution so that I can provide feedback on the service quality.

As a support agent, I want to set ticket reminders so that I can follow up on issues at appropriate times

As a user, I want to access the system on my mobile device so that I can manage tickets while away from my desk




Planned Sprint	Actual Sprint	US ID	User Story Description	MOSCOW	Dependency	Assignee	Status
1	1	US 01	As a customer, I want to be able to create a new support ticket so that I can request assistance for my problems.	MUST HAVE			2- In Progress
1	1	US 02	As a support agent, I want to view all assigned tickets in a dashboard so that I can efficiently manage my workload.	MUST HAVE			1- Not Started
1	1	US 03	As a support agent, I want to update the status of a ticket so that everyone involved knows the current progress.	MUST HAVE			1- Not Started
1	1	US 04	As a customer, I want to receive notifications when there are updates to my tickets so that I'm always informed of progress.	MUST HAVE			1- Not Started
1	1	US 05	As a support agent, I want to add internal notes and customer-visible comments to tickets so that I can document progress and communicate with customers.	MUST HAVE			1- Not Started
1	1	US 06	As a support agent, I want to update ticket status and add comments so that I can communicate progress to customers.	MUST HAVE			1- Not Started
1	1	US 07	As an administrator, I want to view performance metrics and reports so that I can evaluate support team effectiveness and identify improvement areas.	MUST HAVE			1- Not Started
1	1	US 08	As a customer, I want to attach files to tickets so that I can provide screenshots or documents that help explain my issue.	MUST HAVE			1- Not Started
1	1	US 09	As an administrator, I want to manage user roles and permissions so that I can control access to different system functions.	MUST HAVE			1- Not Started
1	1	US 10	As a support agent, I want to search for tickets using keywords so that I can quickly find relevant tickets when helping customers.	SHOULD HAVE			1- Not Started
1	1	US 11	As a user, I want to reset my password if I forget it so that I can regain access to my account.  	MUST HAVE			1- Not Started
1	1	US 12	As a customer, I want to rate my support experience after ticket resolution so that I can provide feedback on the service quality.	MUST HAVE			1- Not Started
1	1	US 13	As a support agent, I want to set ticket reminders so that I can follow up on issues at appropriate times.	SHOULD HAVE			1- Not Started
1	1	US 14	As a user, I want to access the system on my mobile device so that I can manage tickets while away from my desk.  	MUST HAVE			1- Not Started
						
				

//Lombok

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>

<dependency>
    <groupId>jakarta.persistence</groupId>
    <artifactId>jakarta.persistence-api</artifactId>
    <version>3.1.0</version>
</dependency>


// User Entity
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;

    private String name;

    @Column(unique = true)
    private String email;

    private String passwordHash;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_role",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles;
}

// User DTO
public class UserDTO {
    private Long userId;
    private String name;
    private String email;
    private Set<String> roles;
}

// PACKAGE: dto

public class UserSignupRequest {
    private String name;
    private String email;
    private String password;

    public UserSignupRequest() {}

    public UserSignupRequest(String name, String email, String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }

    // Getters and setters

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}


// Role Entity
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long roleId;

    @Enumerated(EnumType.STRING)
    private RoleType name;
}

public enum RoleType {
    CUSTOMER, AGENT, ADMIN
}

// Role DTO
public class RoleDTO {
    private Long roleId;
    private String name;
}

// Ticket Entity
@Entity
@Table(name = "tickets")
public class Ticket {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long ticketId;

    @ManyToOne
    @JoinColumn(name = "customer_id")
    private User customer;

    @ManyToOne
    @JoinColumn(name = "agent_id")
    private User agent;

    private String subject;
    private String description;

    @Enumerated(EnumType.STRING)
    private TicketStatus status;

    @Enumerated(EnumType.STRING)
    private TicketPriority priority;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

public enum TicketStatus {
    OPEN, IN_PROGRESS, RESOLVED, CLOSED
}

public enum TicketPriority {
    LOW, MEDIUM, HIGH, URGENT
}

// Ticket DTO
public class TicketDTO {
    private Long ticketId;
    private Long customerId;
    private Long agentId;
    private String subject;
    private String description;
    private String status;
    private String priority;
}

// Comment Entity
@Entity
@Table(name = "comments")
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long commentId;

    @ManyToOne
    private Ticket ticket;

    @ManyToOne
    private User user;

    private String content;
    private Boolean isInternal;
    private LocalDateTime createdAt;
}

// Comment DTO
public class CommentDTO {
    private Long commentId;
    private Long ticketId;
    private Long userId;
    private String content;
    private Boolean isInternal;
}

// Attachment Entity
@Entity
@Table(name = "attachments")
public class Attachment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long attachmentId;

    @ManyToOne
    private Ticket ticket;

    private String filePath;
    private LocalDateTime uploadedAt;
}

// Attachment DTO
public class AttachmentDTO {
    private Long attachmentId;
    private Long ticketId;
    private String filePath;
}

// Notification Entity
@Entity
@Table(name = "notifications")
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long notificationId;

    @ManyToOne
    private User user;

    @ManyToOne
    private Ticket ticket;

    private String message;
    private Boolean isRead;
    private LocalDateTime createdAt;
}

// Notification DTO
public class NotificationDTO {
    private Long notificationId;
    private Long userId;
    private Long ticketId;
    private String message;
    private Boolean isRead;
}

// TicketReminder Entity
@Entity
@Table(name = "ticket_reminders")
public class TicketReminder {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long reminderId;

    @ManyToOne
    private Ticket ticket;

    private LocalDateTime reminderTime;
    private String message;
    private LocalDateTime createdAt;
}

// TicketReminder DTO
public class TicketReminderDTO {
    private Long reminderId;
    private Long ticketId;
    private LocalDateTime reminderTime;
    private String message;
}

// Feedback Entity
@Entity
@Table(name = "feedback")
public class Feedback {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long feedbackId;

    @OneToOne
    private Ticket ticket;

    private Integer rating;
    private String comment;
    private LocalDateTime submittedAt;
}

// Feedback DTO
public class FeedbackDTO {
    private Long feedbackId;
    private Long ticketId;
    private Integer rating;
    private String comment;
}




// 2. Repositories

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}

public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(RoleType name);
}

public interface TicketRepository extends JpaRepository<Ticket, Long> {
    List<Ticket> findByCustomerUserId(Long customerId);
    List<Ticket> findByAgentUserId(Long agentId);
    List<Ticket> findByStatus(TicketStatus status);
}

public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByTicketTicketId(Long ticketId);
    List<Comment> findByUserUserId(Long userId);
}

public interface AttachmentRepository extends JpaRepository<Attachment, Long> {
    List<Attachment> findByTicketTicketId(Long ticketId);
}

public interface NotificationRepository extends JpaRepository<Notification, Long> {
    List<Notification> findByUserUserId(Long userId);
    List<Notification> findByTicketTicketId(Long ticketId);
    List<Notification> findByIsReadFalse();
}

public interface TicketReminderRepository extends JpaRepository<TicketReminder, Long> {
    List<TicketReminder> findByTicketTicketId(Long ticketId);
}

public interface FeedbackRepository extends JpaRepository<Feedback, Long> {
    Optional<Feedback> findByTicketTicketId(Long ticketId);
}


// PACKAGE: exception

public class ResourceNotFoundException extends RuntimeException { public ResourceNotFoundException(String message) { super(message); } }

public class UnauthorizedAccessException extends RuntimeException { public UnauthorizedAccessException(String message) { super(message); } }

// PACKAGE: mapper

public class UserMapper { public static UserDTO toDTO(User user) { return new UserDTO(user.getUserId(), user.getName(), user.getEmail()); } public static User toEntity(UserSignupRequest request, String passwordHash) { return new User(null, request.getName(), request.getEmail(), passwordHash, null, null); } }

public class TicketMapper { public static TicketDTO toDTO(Ticket ticket) { return new TicketDTO(ticket.getTicketId(), ticket.getSubject(), ticket.getStatus(), ticket.getPriority(), ticket.getCreatedAt(), ticket.getUpdatedAt()); } public static Ticket toEntity(TicketRequestDTO dto, User customer, User agent) { return new Ticket(null, customer, agent, dto.getSubject(), dto.getDescription(), dto.getStatus(), dto.getPriority(), LocalDateTime.now(), LocalDateTime.now()); } }

public class CommentMapper { public static CommentDTO toDTO(Comment comment) { return new CommentDTO(comment.getCommentId(), comment.getText(), comment.isVisibleToCustomer(), comment.getCreatedAt()); } public static Comment toEntity(CommentDTO dto, User user, Ticket ticket) { return new Comment(null, ticket, user, dto.getText(), dto.isVisibleToCustomer(), LocalDateTime.now()); } }

public class FeedbackMapper { public static FeedbackDTO toDTO(Feedback feedback) { return new FeedbackDTO(feedback.getFeedbackId(), feedback.getRating(), feedback.getComment()); } public static Feedback toEntity(FeedbackDTO dto, Ticket ticket, User user) { return new Feedback(null, ticket, user, dto.getRating(), dto.getComment()); } }

public class NotificationMapper { public static NotificationDTO toDTO(Notification n) { return new NotificationDTO(n.getNotificationId(), n.getMessage(), n.isRead(), n.getTimestamp()); } public static Notification toEntity(NotificationDTO dto, User user, Ticket ticket) { return new Notification(null, user, ticket, dto.getMessage(), dto.isRead(), LocalDateTime.now()); } }


// PACKAGE: service

@Service public class UserService { @Autowired private UserRepository userRepository; @Autowired private RoleRepository roleRepository;

public User register(UserSignupRequest request) {
    if (userRepository.findByEmail(request.getEmail()).isPresent()) {
        throw new RuntimeException("Email already registered");
    }
    String passwordHash = PasswordUtil.hashPassword(request.getPassword());
    User user = UserMapper.toEntity(request, passwordHash);
    userRepository.save(user);
    Role role = roleRepository.findByName(RoleType.CUSTOMER).orElseThrow();
    user.getRoles().add(role);
    return userRepository.save(user);
}

public UserDTO getUserById(Long id) {
    return userRepository.findById(id)
            .map(UserMapper::toDTO)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
}

}

@Service public class TicketService { @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Ticket createTicket(TicketRequestDTO dto, Long customerId) {
    User customer = userRepository.findById(customerId)
            .orElseThrow(() -> new ResourceNotFoundException("Customer not found"));
    Ticket ticket = TicketMapper.toEntity(dto, customer, null);
    return ticketRepository.save(ticket);
}

public List<TicketDTO> getTicketsForCustomer(Long customerId) {
    return ticketRepository.findByCustomerUserId(customerId)
            .stream().map(TicketMapper::toDTO).collect(Collectors.toList());
}

public void updateStatus(Long ticketId, TicketStatus status) {
    Ticket ticket = ticketRepository.findById(ticketId)
            .orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    ticket.setStatus(status);
    ticket.setUpdatedAt(LocalDateTime.now());
    ticketRepository.save(ticket);
}

public TicketDTO getTicketById(Long id) {
    Ticket ticket = ticketRepository.findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("Ticket not found with ID: " + id));
    return ticketMapper.toDTO(ticket);
}

public TicketDTO updateTicket(Long id, TicketDTO ticketDTO) {
    Ticket ticket = ticketRepository.findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("Ticket not found with ID: " + id));

    // Update mutable fields
    ticket.setSubject(ticketDTO.getSubject());
    ticket.setDescription(ticketDTO.getDescription());
    ticket.setStatus(ticketDTO.getStatus());
    ticket.setPriority(ticketDTO.getPriority());
    ticket.setAgent(userRepository.findById(ticketDTO.getAgentId()).orElse(null)); // Nullable

    Ticket updatedTicket = ticketRepository.save(ticket);
    return ticketMapper.toDTO(updatedTicket);
}

}

@Service public class CommentService { @Autowired private CommentRepository commentRepository; @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Comment addComment(CommentDTO dto, Long ticketId, Long userId) {
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Comment comment = CommentMapper.toEntity(dto, user, ticket);
    return commentRepository.save(comment);
}

public CommentDTO addComment(CommentDTO commentDto) {
    Ticket ticket = ticketRepository.findById(commentDto.getTicketId())
        .orElseThrow(() -> new ResourceNotFoundException("Ticket not found with ID: " + commentDto.getTicketId()));

    User author = userRepository.findById(commentDto.getAuthorId())
        .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + commentDto.getAuthorId()));

    Comment comment = new Comment();
    comment.setTicket(ticket);
    comment.setAuthor(author);
    comment.setMessage(commentDto.getMessage());
    comment.setCreatedAt(LocalDateTime.now());

    Comment saved = commentRepository.save(comment);
    return commentMapper.toDTO(saved);
}

public List<CommentDTO> getCommentsByTicket(Long ticketId) {
    List<Comment> comments = commentRepository.findByTicketIdOrderByCreatedAtAsc(ticketId);
    return comments.stream()
        .map(commentMapper::toDTO)
        .collect(Collectors.toList());
}

}

@Service public class FeedbackService { @Autowired private FeedbackRepository feedbackRepository; @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Feedback submitFeedback(FeedbackDTO dto, Long ticketId, Long userId) {
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Feedback feedback = FeedbackMapper.toEntity(dto, ticket, user);
    return feedbackRepository.save(feedback);
}

public FeedbackDTO submitFeedback(FeedbackDTO feedbackDto) {
    Ticket ticket = ticketRepository.findById(feedbackDto.getTicketId())
        .orElseThrow(() -> new ResourceNotFoundException("Ticket not found with ID: " + feedbackDto.getTicketId()));

    User author = userRepository.findById(feedbackDto.getUserId())
        .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + feedbackDto.getUserId()));

    Feedback feedback = new Feedback();
    feedback.setTicket(ticket);
    feedback.setUser(author);
    feedback.setMessage(feedbackDto.getMessage());
    feedback.setRating(feedbackDto.getRating());
    feedback.setCreatedAt(LocalDateTime.now());

    Feedback saved = feedbackRepository.save(feedback);
    return feedbackMapper.toDTO(saved);
}

public List<FeedbackDTO> getFeedbackByTicket(Long ticketId) {
    List<Feedback> feedbackList = feedbackRepository.findByTicketIdOrderByCreatedAtDesc(ticketId);
    return feedbackList.stream()
        .map(feedbackMapper::toDTO)
        .collect(Collectors.toList());
}

}

@Service public class NotificationService { @Autowired private NotificationRepository notificationRepository; @Autowired private UserRepository userRepository; @Autowired private TicketRepository ticketRepository;

public Notification createNotification(NotificationDTO dto, Long userId, Long ticketId) {
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    Notification notification = NotificationMapper.toEntity(dto, user, ticket);
    return notificationRepository.save(notification);
}

public List<NotificationDTO> getUnreadNotifications(Long userId) {
    return notificationRepository.findByUserUserId(userId).stream()
            .filter(n -> !n.isRead())
            .map(NotificationMapper::toDTO).collect(Collectors.toList());
}

public List<NotificationDTO> getNotificationsByUser(Long userId) {
    User user = userRepository.findById(userId)
        .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + userId));

    List<Notification> notifications = notificationRepository.findByUserOrderByCreatedAtDesc(user);
    return notifications.stream()
        .map(notificationMapper::toDTO)
        .collect(Collectors.toList());
}

}

public class RoleService {
	public List<RoleDTO> getAllRoles() {
	    List<Role> roles = roleRepository.findAll();
	    return roles.stream()
	        .map(roleMapper::toDTO)
	        .toList();
	}
}



// 6. Controllers

// PACKAGE: controller

package com.example.supportticket.controller;

import com.example.supportticket.dto.; import com.example.supportticket.entity.; import com.example.supportticket.service.; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.;

import java.util.List;

@RestController @RequestMapping("/api/users") public class UserController {

@Autowired
private UserService userService;

@PostMapping("/signup")
public ResponseEntity<UserDto> register(@RequestBody UserSignupRequest request) {
    return ResponseEntity.ok(userService.registerUser(request));
}

@GetMapping("/{id}")
public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
    return ResponseEntity.ok(userService.getUserById(id));
}

}

@RestController @RequestMapping("/api/tickets") public class TicketController {

@Autowired
private TicketService ticketService;

@PostMapping("/")
public ResponseEntity<TicketDto> createTicket(@RequestBody TicketDto ticketDto) {
    return ResponseEntity.ok(ticketService.createTicket(ticketDto));
}

@GetMapping("/{id}")
public ResponseEntity<TicketDto> getTicket(@PathVariable Long id) {
    return ResponseEntity.ok(ticketService.getTicketById(id));
}

@PutMapping("/{id}")
public ResponseEntity<TicketDto> updateTicket(@PathVariable Long id, @RequestBody TicketDto ticketDto) {
    return ResponseEntity.ok(ticketService.updateTicket(id, ticketDto));
}

@GetMapping("/user/{userId}")
public ResponseEntity<List<TicketDto>> getTicketsByUser(@PathVariable Long userId) {
    return ResponseEntity.ok(ticketService.getTicketsByUser(userId));
}

}

@RestController @RequestMapping("/api/comments") public class CommentController {

@Autowired
private CommentService commentService;

@PostMapping("/")
public ResponseEntity<CommentDto> addComment(@RequestBody CommentDto commentDto) {
    return ResponseEntity.ok(commentService.addComment(commentDto));
}

@GetMapping("/ticket/{ticketId}")
public ResponseEntity<List<CommentDto>> getCommentsByTicket(@PathVariable Long ticketId) {
    return ResponseEntity.ok(commentService.getCommentsByTicket(ticketId));
}

}

@RestController @RequestMapping("/api/feedback") public class FeedbackController {

@Autowired
private FeedbackService feedbackService;

@PostMapping("/")
public ResponseEntity<FeedbackDto> submitFeedback(@RequestBody FeedbackDto feedbackDto) {
    return ResponseEntity.ok(feedbackService.submitFeedback(feedbackDto));
}

@GetMapping("/ticket/{ticketId}")
public ResponseEntity<List<FeedbackDto>> getFeedbackByTicket(@PathVariable Long ticketId) {
    return ResponseEntity.ok(feedbackService.getFeedbackByTicket(ticketId));
}

}

@RestController @RequestMapping("/api/notifications") public class NotificationController {

@Autowired
private NotificationService notificationService;

@GetMapping("/user/{userId}")
public ResponseEntity<List<NotificationDto>> getNotificationsByUser(@PathVariable Long userId) {
    return ResponseEntity.ok(notificationService.getNotificationsByUser(userId));
}

}

@RestController @RequestMapping("/api/roles") public class RoleController {

@Autowired
private RoleService roleService;

@GetMapping("/")
public ResponseEntity<List<RoleDto>> getAllRoles() {
    return ResponseEntity.ok(roleService.getAllRoles());
}

}




// PACKAGE: utility

public class PasswordUtil { public static String hashPassword(String plainPassword) { return BCrypt.hashpw(plainPassword, BCrypt.gensalt()); } public static boolean checkPassword(String plainPassword, String hashed) { return BCrypt.checkpw(plainPassword, hashed); } }

public class EmailUtil { public static void sendEmail(String to, String subject, String body) { // Dummy email sending logic (use JavaMailSender in real app) System.out.println("Sending email to " + to); } }

// ResourceNotFoundException.java
package com.example.customersupportticket.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

// GlobalExceptionHandler.java
package com.example.customersupportticket.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFound(ResourceNotFoundException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("message", ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleGenericException(Exception ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("message", "An error occurred: " + ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
