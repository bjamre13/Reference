
//Lombok

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>

<dependency>
    <groupId>jakarta.persistence</groupId>
    <artifactId>jakarta.persistence-api</artifactId>
    <version>3.1.0</version>
</dependency>


// User Entity
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;

    private String name;

    @Column(unique = true)
    private String email;

    private String passwordHash;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_role",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles;
}

// User DTO
public class UserDTO {
    private Long userId;
    private String name;
    private String email;
    private Set<String> roles;
}

// Role Entity
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long roleId;

    @Enumerated(EnumType.STRING)
    private RoleType name;
}

public enum RoleType {
    CUSTOMER, AGENT, ADMIN
}

// Role DTO
public class RoleDTO {
    private Long roleId;
    private String name;
}

// Ticket Entity
@Entity
@Table(name = "tickets")
public class Ticket {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long ticketId;

    @ManyToOne
    @JoinColumn(name = "customer_id")
    private User customer;

    @ManyToOne
    @JoinColumn(name = "agent_id")
    private User agent;

    private String subject;
    private String description;

    @Enumerated(EnumType.STRING)
    private TicketStatus status;

    @Enumerated(EnumType.STRING)
    private TicketPriority priority;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

public enum TicketStatus {
    OPEN, IN_PROGRESS, RESOLVED, CLOSED
}

public enum TicketPriority {
    LOW, MEDIUM, HIGH, URGENT
}

// Ticket DTO
public class TicketDTO {
    private Long ticketId;
    private Long customerId;
    private Long agentId;
    private String subject;
    private String description;
    private String status;
    private String priority;
}

// Comment Entity
@Entity
@Table(name = "comments")
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long commentId;

    @ManyToOne
    private Ticket ticket;

    @ManyToOne
    private User user;

    private String content;
    private Boolean isInternal;
    private LocalDateTime createdAt;
}

// Comment DTO
public class CommentDTO {
    private Long commentId;
    private Long ticketId;
    private Long userId;
    private String content;
    private Boolean isInternal;
}

// Attachment Entity
@Entity
@Table(name = "attachments")
public class Attachment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long attachmentId;

    @ManyToOne
    private Ticket ticket;

    private String filePath;
    private LocalDateTime uploadedAt;
}

// Attachment DTO
public class AttachmentDTO {
    private Long attachmentId;
    private Long ticketId;
    private String filePath;
}

// Notification Entity
@Entity
@Table(name = "notifications")
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long notificationId;

    @ManyToOne
    private User user;

    @ManyToOne
    private Ticket ticket;

    private String message;
    private Boolean isRead;
    private LocalDateTime createdAt;
}

// Notification DTO
public class NotificationDTO {
    private Long notificationId;
    private Long userId;
    private Long ticketId;
    private String message;
    private Boolean isRead;
}

// TicketReminder Entity
@Entity
@Table(name = "ticket_reminders")
public class TicketReminder {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long reminderId;

    @ManyToOne
    private Ticket ticket;

    private LocalDateTime reminderTime;
    private String message;
    private LocalDateTime createdAt;
}

// TicketReminder DTO
public class TicketReminderDTO {
    private Long reminderId;
    private Long ticketId;
    private LocalDateTime reminderTime;
    private String message;
}

// Feedback Entity
@Entity
@Table(name = "feedback")
public class Feedback {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long feedbackId;

    @OneToOne
    private Ticket ticket;

    private Integer rating;
    private String comment;
    private LocalDateTime submittedAt;
}

// Feedback DTO
public class FeedbackDTO {
    private Long feedbackId;
    private Long ticketId;
    private Integer rating;
    private String comment;
}




// 2. Repositories

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}

public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(RoleType name);
}

public interface TicketRepository extends JpaRepository<Ticket, Long> {
    List<Ticket> findByCustomerUserId(Long customerId);
    List<Ticket> findByAgentUserId(Long agentId);
    List<Ticket> findByStatus(TicketStatus status);
}

public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByTicketTicketId(Long ticketId);
    List<Comment> findByUserUserId(Long userId);
}

public interface AttachmentRepository extends JpaRepository<Attachment, Long> {
    List<Attachment> findByTicketTicketId(Long ticketId);
}

public interface NotificationRepository extends JpaRepository<Notification, Long> {
    List<Notification> findByUserUserId(Long userId);
    List<Notification> findByTicketTicketId(Long ticketId);
    List<Notification> findByIsReadFalse();
}

public interface TicketReminderRepository extends JpaRepository<TicketReminder, Long> {
    List<TicketReminder> findByTicketTicketId(Long ticketId);
}

public interface FeedbackRepository extends JpaRepository<Feedback, Long> {
    Optional<Feedback> findByTicketTicketId(Long ticketId);
}




/*********************************************************************************
// 4. Mappers

@Component
public class UserMapper {
    public UserDto toDto(User user) {
        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        dto.setRoles(user.getRoles().stream()
                        .map(role -> role.getName().name())
                        .collect(Collectors.toSet()));
        return dto;
    }
}

@Component
public class TicketMapper {
    public TicketDto toDto(Ticket ticket) {
        TicketDto dto = new TicketDto();
        dto.setId(ticket.getId());
        dto.setTitle(ticket.getTitle());
        dto.setDescription(ticket.getDescription());
        dto.setStatus(ticket.getStatus().name());
        dto.setPriority(ticket.getPriority().name());
        dto.setCreatedById(ticket.getCreatedBy() != null ? ticket.getCreatedBy().getId() : null);
        dto.setAssignedToId(ticket.getAssignedTo() != null ? ticket.getAssignedTo().getId() : null);
        return dto;
    }
}


// 5. Services

@Service
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    
    public UserService(UserRepository userRepository, RoleRepository roleRepository) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
    }

    public User createUser(String username, String email, String password, Set<RoleName> roles) {
        User user = new User();
        user.setUsername(username);
        user.setEmail(email);
        user.setPassword(password);
        
        Set<Role> roleSet = roles.stream()
                .map(roleName -> roleRepository.findByName(roleName)
                        .orElseThrow(() -> new RuntimeException("Role not found: " + roleName)))
                .collect(Collectors.toSet());
        
        user.setRoles(roleSet);
        return userRepository.save(user);
    }
}

@Service
public class TicketService {
    private final TicketRepository ticketRepository;
    private final TicketMapper ticketMapper;

    public TicketService(TicketRepository ticketRepository, TicketMapper ticketMapper) {
        this.ticketRepository = ticketRepository;
        this.ticketMapper = ticketMapper;
    }

    public TicketDto createTicket(TicketDto ticketDto) {
        Ticket ticket = new Ticket();
        ticket.setTitle(ticketDto.getTitle());
        ticket.setDescription(ticketDto.getDescription());
        ticket.setStatus(Status.valueOf(ticketDto.getStatus()));
        ticket.setPriority(Priority.valueOf(ticketDto.getPriority()));
        // setting createdBy and assignedTo can be handled separately
        Ticket saved = ticketRepository.save(ticket);
        return ticketMapper.toDto(saved);
    }
}

@Service
public class TicketCommentService {
    private final TicketCommentRepository commentRepository;

    public TicketCommentService(TicketCommentRepository commentRepository) {
        this.commentRepository = commentRepository;
    }

    public TicketComment addComment(TicketComment comment) {
        return commentRepository.save(comment);
    }
}********************************************************************************/


// PACKAGE: exception

public class ResourceNotFoundException extends RuntimeException { public ResourceNotFoundException(String message) { super(message); } }

public class UnauthorizedAccessException extends RuntimeException { public UnauthorizedAccessException(String message) { super(message); } }

// PACKAGE: mapper

public class UserMapper { public static UserDTO toDTO(User user) { return new UserDTO(user.getUserId(), user.getName(), user.getEmail()); } public static User toEntity(UserSignupRequest request, String passwordHash) { return new User(null, request.getName(), request.getEmail(), passwordHash, null, null); } }

public class TicketMapper { public static TicketDTO toDTO(Ticket ticket) { return new TicketDTO(ticket.getTicketId(), ticket.getSubject(), ticket.getStatus(), ticket.getPriority(), ticket.getCreatedAt(), ticket.getUpdatedAt()); } public static Ticket toEntity(TicketRequestDTO dto, User customer, User agent) { return new Ticket(null, customer, agent, dto.getSubject(), dto.getDescription(), dto.getStatus(), dto.getPriority(), LocalDateTime.now(), LocalDateTime.now()); } }

public class CommentMapper { public static CommentDTO toDTO(Comment comment) { return new CommentDTO(comment.getCommentId(), comment.getText(), comment.isVisibleToCustomer(), comment.getCreatedAt()); } public static Comment toEntity(CommentDTO dto, User user, Ticket ticket) { return new Comment(null, ticket, user, dto.getText(), dto.isVisibleToCustomer(), LocalDateTime.now()); } }

public class FeedbackMapper { public static FeedbackDTO toDTO(Feedback feedback) { return new FeedbackDTO(feedback.getFeedbackId(), feedback.getRating(), feedback.getComment()); } public static Feedback toEntity(FeedbackDTO dto, Ticket ticket, User user) { return new Feedback(null, ticket, user, dto.getRating(), dto.getComment()); } }

public class NotificationMapper { public static NotificationDTO toDTO(Notification n) { return new NotificationDTO(n.getNotificationId(), n.getMessage(), n.isRead(), n.getTimestamp()); } public static Notification toEntity(NotificationDTO dto, User user, Ticket ticket) { return new Notification(null, user, ticket, dto.getMessage(), dto.isRead(), LocalDateTime.now()); } }

// PACKAGE: utility

public class PasswordUtil { public static String hashPassword(String plainPassword) { return BCrypt.hashpw(plainPassword, BCrypt.gensalt()); } public static boolean checkPassword(String plainPassword, String hashed) { return BCrypt.checkpw(plainPassword, hashed); } }

public class EmailUtil { public static void sendEmail(String to, String subject, String body) { // Dummy email sending logic (use JavaMailSender in real app) System.out.println("Sending email to " + to); } }

// PACKAGE: service

@Service public class UserService { @Autowired private UserRepository userRepository; @Autowired private RoleRepository roleRepository;

public User register(UserSignupRequest request) {
    if (userRepository.findByEmail(request.getEmail()).isPresent()) {
        throw new RuntimeException("Email already registered");
    }
    String passwordHash = PasswordUtil.hashPassword(request.getPassword());
    User user = UserMapper.toEntity(request, passwordHash);
    userRepository.save(user);
    Role role = roleRepository.findByName(RoleType.CUSTOMER).orElseThrow();
    user.getRoles().add(role);
    return userRepository.save(user);
}

public UserDTO getUserById(Long id) {
    return userRepository.findById(id)
            .map(UserMapper::toDTO)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
}

}

@Service public class TicketService { @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Ticket createTicket(TicketRequestDTO dto, Long customerId) {
    User customer = userRepository.findById(customerId)
            .orElseThrow(() -> new ResourceNotFoundException("Customer not found"));
    Ticket ticket = TicketMapper.toEntity(dto, customer, null);
    return ticketRepository.save(ticket);
}

public List<TicketDTO> getTicketsForCustomer(Long customerId) {
    return ticketRepository.findByCustomerUserId(customerId)
            .stream().map(TicketMapper::toDTO).collect(Collectors.toList());
}

public void updateStatus(Long ticketId, TicketStatus status) {
    Ticket ticket = ticketRepository.findById(ticketId)
            .orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    ticket.setStatus(status);
    ticket.setUpdatedAt(LocalDateTime.now());
    ticketRepository.save(ticket);
}

}

@Service public class CommentService { @Autowired private CommentRepository commentRepository; @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Comment addComment(CommentDTO dto, Long ticketId, Long userId) {
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Comment comment = CommentMapper.toEntity(dto, user, ticket);
    return commentRepository.save(comment);
}

}

@Service public class FeedbackService { @Autowired private FeedbackRepository feedbackRepository; @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Feedback submitFeedback(FeedbackDTO dto, Long ticketId, Long userId) {
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Feedback feedback = FeedbackMapper.toEntity(dto, ticket, user);
    return feedbackRepository.save(feedback);
}

}

@Service public class NotificationService { @Autowired private NotificationRepository notificationRepository; @Autowired private UserRepository userRepository; @Autowired private TicketRepository ticketRepository;

public Notification createNotification(NotificationDTO dto, Long userId, Long ticketId) {
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    Notification notification = NotificationMapper.toEntity(dto, user, ticket);
    return notificationRepository.save(notification);
}

public List<NotificationDTO> getUnreadNotifications(Long userId) {
    return notificationRepository.findByUserUserId(userId).stream()
            .filter(n -> !n.isRead())
            .map(NotificationMapper::toDTO).collect(Collectors.toList());
}

}


// PACKAGE: exception

public class ResourceNotFoundException extends RuntimeException { public ResourceNotFoundException(String message) { super(message); } }

public class UnauthorizedAccessException extends RuntimeException { public UnauthorizedAccessException(String message) { super(message); } }

// PACKAGE: mapper

public class UserMapper { public static UserDTO toDTO(User user) { return new UserDTO(user.getUserId(), user.getName(), user.getEmail()); } public static User toEntity(UserSignupRequest request, String passwordHash) { return new User(null, request.getName(), request.getEmail(), passwordHash, null, null); } }

public class TicketMapper { public static TicketDTO toDTO(Ticket ticket) { return new TicketDTO(ticket.getTicketId(), ticket.getSubject(), ticket.getStatus(), ticket.getPriority(), ticket.getCreatedAt(), ticket.getUpdatedAt()); } public static Ticket toEntity(TicketRequestDTO dto, User customer, User agent) { return new Ticket(null, customer, agent, dto.getSubject(), dto.getDescription(), dto.getStatus(), dto.getPriority(), LocalDateTime.now(), LocalDateTime.now()); } }

public class CommentMapper { public static CommentDTO toDTO(Comment comment) { return new CommentDTO(comment.getCommentId(), comment.getText(), comment.isVisibleToCustomer(), comment.getCreatedAt()); } public static Comment toEntity(CommentDTO dto, User user, Ticket ticket) { return new Comment(null, ticket, user, dto.getText(), dto.isVisibleToCustomer(), LocalDateTime.now()); } }

public class FeedbackMapper { public static FeedbackDTO toDTO(Feedback feedback) { return new FeedbackDTO(feedback.getFeedbackId(), feedback.getRating(), feedback.getComment()); } public static Feedback toEntity(FeedbackDTO dto, Ticket ticket, User user) { return new Feedback(null, ticket, user, dto.getRating(), dto.getComment()); } }

public class NotificationMapper { public static NotificationDTO toDTO(Notification n) { return new NotificationDTO(n.getNotificationId(), n.getMessage(), n.isRead(), n.getTimestamp()); } public static Notification toEntity(NotificationDTO dto, User user, Ticket ticket) { return new Notification(null, user, ticket, dto.getMessage(), dto.isRead(), LocalDateTime.now()); } }

// PACKAGE: utility

public class PasswordUtil { public static String hashPassword(String plainPassword) { return BCrypt.hashpw(plainPassword, BCrypt.gensalt()); } public static boolean checkPassword(String plainPassword, String hashed) { return BCrypt.checkpw(plainPassword, hashed); } }

public class EmailUtil { public static void sendEmail(String to, String subject, String body) { // Dummy email sending logic (use JavaMailSender in real app) System.out.println("Sending email to " + to); } }

// PACKAGE: service

@Service public class UserService { @Autowired private UserRepository userRepository; @Autowired private RoleRepository roleRepository;

public User register(UserSignupRequest request) {
    if (userRepository.findByEmail(request.getEmail()).isPresent()) {
        throw new RuntimeException("Email already registered");
    }
    String passwordHash = PasswordUtil.hashPassword(request.getPassword());
    User user = UserMapper.toEntity(request, passwordHash);
    userRepository.save(user);
    Role role = roleRepository.findByName(RoleType.CUSTOMER).orElseThrow();
    user.getRoles().add(role);
    return userRepository.save(user);
}

public UserDTO getUserById(Long id) {
    return userRepository.findById(id)
            .map(UserMapper::toDTO)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
}

}

@Service public class TicketService { @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Ticket createTicket(TicketRequestDTO dto, Long customerId) {
    User customer = userRepository.findById(customerId)
            .orElseThrow(() -> new ResourceNotFoundException("Customer not found"));
    Ticket ticket = TicketMapper.toEntity(dto, customer, null);
    return ticketRepository.save(ticket);
}

public List<TicketDTO> getTicketsForCustomer(Long customerId) {
    return ticketRepository.findByCustomerUserId(customerId)
            .stream().map(TicketMapper::toDTO).collect(Collectors.toList());
}

public void updateStatus(Long ticketId, TicketStatus status) {
    Ticket ticket = ticketRepository.findById(ticketId)
            .orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    ticket.setStatus(status);
    ticket.setUpdatedAt(LocalDateTime.now());
    ticketRepository.save(ticket);
}

}

@Service public class CommentService { @Autowired private CommentRepository commentRepository; @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Comment addComment(CommentDTO dto, Long ticketId, Long userId) {
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Comment comment = CommentMapper.toEntity(dto, user, ticket);
    return commentRepository.save(comment);
}

}

@Service public class FeedbackService { @Autowired private FeedbackRepository feedbackRepository; @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Feedback submitFeedback(FeedbackDTO dto, Long ticketId, Long userId) {
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Feedback feedback = FeedbackMapper.toEntity(dto, ticket, user);
    return feedbackRepository.save(feedback);
}

}

@Service public class NotificationService { @Autowired private NotificationRepository notificationRepository; @Autowired private UserRepository userRepository; @Autowired private TicketRepository ticketRepository;

public Notification createNotification(NotificationDTO dto, Long userId, Long ticketId) {
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    Notification notification = NotificationMapper.toEntity(dto, user, ticket);
    return notificationRepository.save(notification);
}

public List<NotificationDTO> getUnreadNotifications(Long userId) {
    return notificationRepository.findByUserUserId(userId).stream()
            .filter(n -> !n.isRead())
            .map(NotificationMapper::toDTO).collect(Collectors.toList());
}

}





// 6. Controllers

@RestController
@RequestMapping("/api/users")
public class UserController {
    private final UserService userService;
    private final UserMapper userMapper;

    public UserController(UserService userService, UserMapper userMapper) {
        this.userService = userService;
        this.userMapper = userMapper;
    }

    @PostMapping
    public ResponseEntity<UserDto> createUser(@RequestBody UserDto userDto) {
        Set<RoleName> roles = userDto.getRoles().stream()
                .map(RoleName::valueOf)
                .collect(Collectors.toSet());
        
        User user = userService.createUser(userDto.getUsername(), userDto.getEmail(), userDto.getPassword(), roles);
        return ResponseEntity.ok(userMapper.toDto(user));
    }
}

@RestController
@RequestMapping("/api/tickets")
public class TicketController {
    private final TicketService ticketService;

    public TicketController(TicketService ticketService) {
        this.ticketService = ticketService;
    }

    @PostMapping
    public ResponseEntity<TicketDto> createTicket(@RequestBody TicketDto ticketDto) {
        TicketDto createdTicket = ticketService.createTicket(ticketDto);
        return ResponseEntity.ok(createdTicket);
    }
}

@RestController
@RequestMapping("/api/comments")
public class TicketCommentController {
    private final TicketCommentService commentService;

    public TicketCommentController(TicketCommentService commentService) {
        this.commentService = commentService;
    }

    @PostMapping
    public ResponseEntity<TicketComment> addComment(@RequestBody TicketComment comment) {
        TicketComment savedComment = commentService.addComment(comment);
        return ResponseEntity.ok(savedComment);
    }
}


// ModelMapperConfig.java
package com.example.customersupportticket.util;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ModelMapperConfig {

    @Bean
    public ModelMapper modelMapper() {
        return new ModelMapper();
    }
}

// ResourceNotFoundException.java
package com.example.customersupportticket.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

// GlobalExceptionHandler.java
package com.example.customersupportticket.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFound(ResourceNotFoundException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("message", ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleGenericException(Exception ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("message", "An error occurred: " + ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
