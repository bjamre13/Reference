
//Lombok

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>

<dependency>
    <groupId>jakarta.persistence</groupId>
    <artifactId>jakarta.persistence-api</artifactId>
    <version>3.1.0</version>
</dependency>


// User Entity
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;

    private String name;

    @Column(unique = true)
    private String email;

    private String passwordHash;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_role",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles;
}

// User DTO
public class UserDTO {
    private Long userId;
    private String name;
    private String email;
    private Set<String> roles;
}

// PACKAGE: dto

public class UserSignupRequest {
    private String name;
    private String email;
    private String password;

    public UserSignupRequest() {}

    public UserSignupRequest(String name, String email, String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }

    // Getters and setters

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}


// Role Entity
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long roleId;

    @Enumerated(EnumType.STRING)
    private RoleType name;
}

public enum RoleType {
    CUSTOMER, AGENT, ADMIN
}

// Role DTO
public class RoleDTO {
    private Long roleId;
    private String name;
}

// Ticket Entity
@Entity
@Table(name = "tickets")
public class Ticket {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long ticketId;

    @ManyToOne
    @JoinColumn(name = "customer_id")
    private User customer;

    @ManyToOne
    @JoinColumn(name = "agent_id")
    private User agent;

    private String subject;
    private String description;

    @Enumerated(EnumType.STRING)
    private TicketStatus status;

    @Enumerated(EnumType.STRING)
    private TicketPriority priority;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

public enum TicketStatus {
    OPEN, IN_PROGRESS, RESOLVED, CLOSED
}

public enum TicketPriority {
    LOW, MEDIUM, HIGH, URGENT
}

// Ticket DTO
public class TicketDTO {
    private Long ticketId;
    private Long customerId;
    private Long agentId;
    private String subject;
    private String description;
    private String status;
    private String priority;
}

// Comment Entity
@Entity
@Table(name = "comments")
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long commentId;

    @ManyToOne
    private Ticket ticket;

    @ManyToOne
    private User user;

    private String content;
    private Boolean isInternal;
    private LocalDateTime createdAt;
}

// Comment DTO
public class CommentDTO {
    private Long commentId;
    private Long ticketId;
    private Long userId;
    private String content;
    private Boolean isInternal;
}

// Attachment Entity
@Entity
@Table(name = "attachments")
public class Attachment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long attachmentId;

    @ManyToOne
    private Ticket ticket;

    private String filePath;
    private LocalDateTime uploadedAt;
}

// Attachment DTO
public class AttachmentDTO {
    private Long attachmentId;
    private Long ticketId;
    private String filePath;
}

// Notification Entity
@Entity
@Table(name = "notifications")
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long notificationId;

    @ManyToOne
    private User user;

    @ManyToOne
    private Ticket ticket;

    private String message;
    private Boolean isRead;
    private LocalDateTime createdAt;
}

// Notification DTO
public class NotificationDTO {
    private Long notificationId;
    private Long userId;
    private Long ticketId;
    private String message;
    private Boolean isRead;
}

// TicketReminder Entity
@Entity
@Table(name = "ticket_reminders")
public class TicketReminder {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long reminderId;

    @ManyToOne
    private Ticket ticket;

    private LocalDateTime reminderTime;
    private String message;
    private LocalDateTime createdAt;
}

// TicketReminder DTO
public class TicketReminderDTO {
    private Long reminderId;
    private Long ticketId;
    private LocalDateTime reminderTime;
    private String message;
}

// Feedback Entity
@Entity
@Table(name = "feedback")
public class Feedback {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long feedbackId;

    @OneToOne
    private Ticket ticket;

    private Integer rating;
    private String comment;
    private LocalDateTime submittedAt;
}

// Feedback DTO
public class FeedbackDTO {
    private Long feedbackId;
    private Long ticketId;
    private Integer rating;
    private String comment;
}




// 2. Repositories

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}

public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(RoleType name);
}

public interface TicketRepository extends JpaRepository<Ticket, Long> {
    List<Ticket> findByCustomerUserId(Long customerId);
    List<Ticket> findByAgentUserId(Long agentId);
    List<Ticket> findByStatus(TicketStatus status);
}

public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByTicketTicketId(Long ticketId);
    List<Comment> findByUserUserId(Long userId);
}

public interface AttachmentRepository extends JpaRepository<Attachment, Long> {
    List<Attachment> findByTicketTicketId(Long ticketId);
}

public interface NotificationRepository extends JpaRepository<Notification, Long> {
    List<Notification> findByUserUserId(Long userId);
    List<Notification> findByTicketTicketId(Long ticketId);
    List<Notification> findByIsReadFalse();
}

public interface TicketReminderRepository extends JpaRepository<TicketReminder, Long> {
    List<TicketReminder> findByTicketTicketId(Long ticketId);
}

public interface FeedbackRepository extends JpaRepository<Feedback, Long> {
    Optional<Feedback> findByTicketTicketId(Long ticketId);
}


// PACKAGE: exception

public class ResourceNotFoundException extends RuntimeException { public ResourceNotFoundException(String message) { super(message); } }

public class UnauthorizedAccessException extends RuntimeException { public UnauthorizedAccessException(String message) { super(message); } }

// PACKAGE: mapper

public class UserMapper { public static UserDTO toDTO(User user) { return new UserDTO(user.getUserId(), user.getName(), user.getEmail()); } public static User toEntity(UserSignupRequest request, String passwordHash) { return new User(null, request.getName(), request.getEmail(), passwordHash, null, null); } }

public class TicketMapper { public static TicketDTO toDTO(Ticket ticket) { return new TicketDTO(ticket.getTicketId(), ticket.getSubject(), ticket.getStatus(), ticket.getPriority(), ticket.getCreatedAt(), ticket.getUpdatedAt()); } public static Ticket toEntity(TicketRequestDTO dto, User customer, User agent) { return new Ticket(null, customer, agent, dto.getSubject(), dto.getDescription(), dto.getStatus(), dto.getPriority(), LocalDateTime.now(), LocalDateTime.now()); } }

public class CommentMapper { public static CommentDTO toDTO(Comment comment) { return new CommentDTO(comment.getCommentId(), comment.getText(), comment.isVisibleToCustomer(), comment.getCreatedAt()); } public static Comment toEntity(CommentDTO dto, User user, Ticket ticket) { return new Comment(null, ticket, user, dto.getText(), dto.isVisibleToCustomer(), LocalDateTime.now()); } }

public class FeedbackMapper { public static FeedbackDTO toDTO(Feedback feedback) { return new FeedbackDTO(feedback.getFeedbackId(), feedback.getRating(), feedback.getComment()); } public static Feedback toEntity(FeedbackDTO dto, Ticket ticket, User user) { return new Feedback(null, ticket, user, dto.getRating(), dto.getComment()); } }

public class NotificationMapper { public static NotificationDTO toDTO(Notification n) { return new NotificationDTO(n.getNotificationId(), n.getMessage(), n.isRead(), n.getTimestamp()); } public static Notification toEntity(NotificationDTO dto, User user, Ticket ticket) { return new Notification(null, user, ticket, dto.getMessage(), dto.isRead(), LocalDateTime.now()); } }


// PACKAGE: service

@Service public class UserService { @Autowired private UserRepository userRepository; @Autowired private RoleRepository roleRepository;

public User register(UserSignupRequest request) {
    if (userRepository.findByEmail(request.getEmail()).isPresent()) {
        throw new RuntimeException("Email already registered");
    }
    String passwordHash = PasswordUtil.hashPassword(request.getPassword());
    User user = UserMapper.toEntity(request, passwordHash);
    userRepository.save(user);
    Role role = roleRepository.findByName(RoleType.CUSTOMER).orElseThrow();
    user.getRoles().add(role);
    return userRepository.save(user);
}

public UserDTO getUserById(Long id) {
    return userRepository.findById(id)
            .map(UserMapper::toDTO)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
}

}

@Service public class TicketService { @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Ticket createTicket(TicketRequestDTO dto, Long customerId) {
    User customer = userRepository.findById(customerId)
            .orElseThrow(() -> new ResourceNotFoundException("Customer not found"));
    Ticket ticket = TicketMapper.toEntity(dto, customer, null);
    return ticketRepository.save(ticket);
}

public List<TicketDTO> getTicketsForCustomer(Long customerId) {
    return ticketRepository.findByCustomerUserId(customerId)
            .stream().map(TicketMapper::toDTO).collect(Collectors.toList());
}

public void updateStatus(Long ticketId, TicketStatus status) {
    Ticket ticket = ticketRepository.findById(ticketId)
            .orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    ticket.setStatus(status);
    ticket.setUpdatedAt(LocalDateTime.now());
    ticketRepository.save(ticket);
}

}

@Service public class CommentService { @Autowired private CommentRepository commentRepository; @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Comment addComment(CommentDTO dto, Long ticketId, Long userId) {
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Comment comment = CommentMapper.toEntity(dto, user, ticket);
    return commentRepository.save(comment);
}

}

@Service public class FeedbackService { @Autowired private FeedbackRepository feedbackRepository; @Autowired private TicketRepository ticketRepository; @Autowired private UserRepository userRepository;

public Feedback submitFeedback(FeedbackDTO dto, Long ticketId, Long userId) {
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Feedback feedback = FeedbackMapper.toEntity(dto, ticket, user);
    return feedbackRepository.save(feedback);
}

}

@Service public class NotificationService { @Autowired private NotificationRepository notificationRepository; @Autowired private UserRepository userRepository; @Autowired private TicketRepository ticketRepository;

public Notification createNotification(NotificationDTO dto, Long userId, Long ticketId) {
    User user = userRepository.findById(userId).orElseThrow(() -> new ResourceNotFoundException("User not found"));
    Ticket ticket = ticketRepository.findById(ticketId).orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
    Notification notification = NotificationMapper.toEntity(dto, user, ticket);
    return notificationRepository.save(notification);
}

public List<NotificationDTO> getUnreadNotifications(Long userId) {
    return notificationRepository.findByUserUserId(userId).stream()
            .filter(n -> !n.isRead())
            .map(NotificationMapper::toDTO).collect(Collectors.toList());
}

}


// 6. Controllers




// PACKAGE: utility

public class PasswordUtil { public static String hashPassword(String plainPassword) { return BCrypt.hashpw(plainPassword, BCrypt.gensalt()); } public static boolean checkPassword(String plainPassword, String hashed) { return BCrypt.checkpw(plainPassword, hashed); } }

public class EmailUtil { public static void sendEmail(String to, String subject, String body) { // Dummy email sending logic (use JavaMailSender in real app) System.out.println("Sending email to " + to); } }

// ResourceNotFoundException.java
package com.example.customersupportticket.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

// GlobalExceptionHandler.java
package com.example.customersupportticket.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFound(ResourceNotFoundException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("message", ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleGenericException(Exception ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("message", "An error occurred: " + ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
